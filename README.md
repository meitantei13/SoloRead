# Solo Read
誰にも見られない、自分だけの読書管理アプリ。   
「Solo Read」は、あなただけが開ける**秘密の本棚**です。

![Image](https://github.com/user-attachments/assets/bf98e7d5-7b9f-447a-a52a-b660f4906b49)

## サービスURL
https://solo-read.click

## 目次
- [サービス概要](#サービス概要)
- [主な機能](#主な機能)
- [技術スタック](#技術スタック)
  - [技術選定理由](#技術選定理由)
  - [テスト・CI/CD](#テストcicd)
- [画面操作](#画面操作)
- [システム構成](#システム構成)
  - [インフラ構成図](#インフラ構成図)
  - [ER図](#er図)
- [設計で工夫した点](#設計で工夫した点)
  - [完全非公開設計](#完全非公開設計)
  - [Rails API ✕ Next.js の分離構成](#rails-api--nextjs-の分離構成)
  - [ゲストユーザーの仕様設計](#ゲストユーザーの仕様設計)
- [苦労した点・学んだこと](#苦労した点学んだこと)
  - [ログインが不安定になる問題の原因調査と改善](#ログインが不安定になる問題の原因調査と改善)
  - [ゲストユーザーの自動削除機能の実装](#ゲストユーザーの自動削除機能の実装)
  - [読了日登録時のカレンダーUIの調整](#読了日登録時のカレンダーuiの調整)
- [ユーザーフィードバックをもとに改善した点](#ユーザーフィードバックをもとに改善した点)
- [今後の改善予定](#今後の改善予定)


## サービス概要
「Solo Read」は、**完全非公開を前提とした個人用読書管理アプリ**です。  
既存の読書記録アプリでは、感想や読書履歴が他ユーザーに共有される設定が多く、「評価されること」を前提としたアウトプットになりやすいと感じていました。

その結果、
- 本音ではなく無難な感想を書いてしまう。
- 他人の評価を意識してしまい、記録が続かない。
- 読書記録が「自分のためのログ」にならない。
という課題が生まれていると考えました。

そこで、本アプリでは、
**「読書記録は他人に見せるものではなく、自分自身と向き合うためのもの」**
という前提を置き、完全非公開を軸とした機能・データ設計を行っています。



## 主な機能

### 認証・利用開始
- **ユーザー登録（メール認証） / ログイン・ログアウト**  
  本人のみがアクセスできる完全非公開設計を前提とし、認証メールによる本人確認フローを実装。

- **ゲストログイン**
  アカウント作成前に、記録体験を試せる導線として用意。

- **レスポンシブ対応**
  読書中にさっとメモできるよう、スマートフォンやタブレットでも快適に利用可能。

### 読書記録の管理
- **読書記録の登録・編集・削除**  
  読んだ本の感想や気づきを自由に記録可能。

- **読書中保存機能（下書き）**  
  読書途中の思考を途切れさせずに残せるよう、下書き保存に対応。

### 一覧・検索
- **読書記録一覧 / 読書中一覧**  
  読了済・読書中の記録を状態別に一覧表示。

- **ジャンル管理・絞り込み検索**  
  記事登録時にジャンルを指定し、読了済一覧ではジャンル別の絞り込み表示に対応。  
  絞り込み状態を維持したまま、タイトル・著者名での非同期検索が可能。

### 振り返り
- **読書冊数の可視化（マイページ）**  
  今月・今年・累計の読書量を確認可能。

### アカウント管理
- **メールアドレス変更**  
  確認メールによる再認証フローを実装。

- **パスワード・ユーザー名変更 / アカウント削除**  
  ログイン中ユーザーが自身のアカウント情報を管理可能。



## 技術スタック

| 分類 | 技術 |
| --- | --- |
| フロントエンド | Next.js / TypeScript |
| バックエンド | Ruby on Rails (APIモード) |
| 認証 | Devise / Devise Token Auth |
| データベース | MySQL |
| 非同期処理 | Sidekiq (sidekiq-cron) |
| キャッシュ / キュー | Redis |
| インフラ | AWS |
| 開発環境 | Docker / Docker Compose |

フロントエンドは Next.js による SPA 構成とし、Rails API と通信しています。  
データ取得には SWR を使用し、キャッシュと再検証を行っています。  


### 技術選定理由

**フロントエンド：Next.js (TypeScript)**  
読書記録の検索や一覧更新、編集状態の切り替えなど、ユーザー操作に応じて画面が頻繁に変化するアプリのため、画面上で状態を持ちながら非同期通信を行える構成が必要でした。

読書記録の一覧・検索・編集を同一画面で行う場面が多く、コンポーネント単位で状態を分離して管理できる点を重視し、React ベースの Next.js を採用しました。

また、TypeScript により API レスポンスや画面で扱うデータ構造を型として定義することで、
フロントエンドとバックエンド間の不整合を防ぎながら、安全に実装できるようにしています。

データ取得には SWR を使用し、一覧表示や検索時の再取得制御を useEffect で個別に管理する必要がなくなり、
状態管理の複雑化を避けられると考えました。


**バックエンド：Ruby on Rails (API モード)**  
認証やバリデーション、ユーザーごとのデータ管理といった、アプリケーションの基盤処理をサーバー側に集約したいと考え、
バックエンドには Ruby on Rails を API サーバーとして採用しました。

また、日本語の情報や実務での利用事例が多く、運用やトラブル対応まで含めた知見が蓄積されている点も重視しています。
これにより、問題発生時にも解決策を見つけやすく、開発スピードを維持しながら安定した改善が行えると考えました。

フロントエンドを Next.js と分離した API 構成とすることで、UI 側の実装に影響を与えずに、認証方式やデータ構造の変更・拡張が行えるよう、保守性と拡張性を意識した設計としています。


**インフラ：AWS + Docker**  
個人開発であっても、本番運用を想定した構成で設計・運用する経験を得ることを目的として、
インフラには AWS と Docker を採用しました。

アプリケーションをコンテナ化し、ECS（Fargate）上で実行することで、サーバー管理を意識せずにデプロイ・スケールが行える構成とし、開発環境と本番環境の差異を小さく保つことを重視しています。

また、ALB によるトラフィックの分離と RDS によるデータベース管理を組み合わせることで、フロントエンドとバックエンドを独立して更新・スケールできる構成としました。

これにより、機能追加やデプロイ時にもサービス全体を停止させることなく、継続的に改善・運用できる設計としています。


### テスト・CI/CD

品質を担保しながら継続的に改善できる開発体制を意識し、テストと CI/CD を導入しています。

バックエンドでは RSpec によるモデル・リクエストスペックを作成し、機能追加や修正時にデグレードを防止できる構成としています。
フロントエンドでは ESLint / Prettier によるコード品質チェックを行い、一貫したコードスタイルを維持しています。

また、GitHub Actions を用いて push 時に自動でテスト・Lint を実行し、main ブランチへのマージで AWS ECS へ自動デプロイされるパイプラインを構築しました。
これにより、手動デプロイによるミスを防ぎ、安定したリリースサイクルを実現しています。



## 画面操作

### 新規登録・ログイン

新規登録・ログイン方法は以下の3通りです。
- ゲストログイン
- メールアドレスとパスワードで新規登録
- メールアドレスとパスワードでログイン

※動画ではゲストログインを表示しています。  
※ゲストログインでは自動でサンプルデータが追加されています。

![Image](https://github.com/user-attachments/assets/f16505cb-a996-4988-9255-9be3cc47a3b0)
  


### 読書記録の新規登録

読書記録の新規登録画面です。
登録には以下の5項目の入力が必要です。
1. 書名
2. 著者
3. ジャンル
4. 読了日
5. 感想

各項目を入力後、画面上部で**読書中**か**読了済**を選択し、**更新する**ボタンを押します。  
※読書中で更新する場合は、書名のみが必須項目となります。

![Image](https://github.com/user-attachments/assets/5cff5766-9845-468d-9933-979528dc12bc)
  


### 登録一覧からデータを検索

本一覧＆検索画面から、読了済で登録したデータを検索することができます。  
検索バーに入力すると自動で検索が開始されます。  
検索範囲は**書名**と**著者**です。  

また、ジャンルを選択することで、指定したジャンルの本のみを表示することができます。  
ジャンルを指定した後に検索を行うことで、**指定したジャンル内での検索**が可能です。

![Image](https://github.com/user-attachments/assets/100ffaf8-3766-42ce-9f59-4163541ad14d)
  


## システム構成
### インフラ構成図
#### 全体構成
- フロントエンドとバックエンドを AWS 上で分離構成として構築
- Route53 による DNS 管理
- ACM による SSL / TLS 証明書の管理
- ALB を経由して Frontend / Backend へリクエストを振り分け

#### フロントエンド (ECS / Fargate)
- Next.js を Docker コンテナとして ECS 上で実行
- ALB 経由でアクセスを受け付ける構成
- GitHub Actions を用いた CI / CD により自動デプロイパイプラインを構築

#### バックエンド (ECS / Fargate)
- Rails API を Docker コンテナとして ECS 上で実行
- データベースは RDS (MySQL) を Private Subnet に配置
- GitHub Actions と ECR を連携した自動デプロイパイプラインを構築
- アプリケーションの応答性と安全性を保つため、Sidekiq と Redis (ElastiCache) を用いた非同期処理基盤を構築

![Image](https://github.com/user-attachments/assets/bf98e7d5-7b9f-447a-a52a-b660f4906b49)
  


### ER図
- 完全非公開の読書記録をユーザー単位で管理するため、User と Book を**1対多**の関係で設計
- Genre は共通で利用できるデフォルトジャンルと、ユーザーが独自に追加できるジャンルの両方を扱えるよう、user_id を nullable とした設計

![Image](https://github.com/user-attachments/assets/47419760-fa3c-4846-9cc9-d28e40649a84)
  
  

## 設計で工夫した点
### 完全非公開設計
本アプリは、誰にも見られない「自分だけの読書記録」を前提としているため、他ユーザーのデータが表示・検索されない完全非公開設計としています。

すべての読書記録は user_id を基準に管理し、バックエンドの API では常に認証中ユーザーを起点にデータを取得することで、他ユーザーのデータにアクセスできないよう制御しています。

これにより、フロントエンド側の実装に依存せず、サーバー側でデータのスコープを保証する設計としています。


### Rails API ✕ Next.js の分離構成
バックエンドは Rails を API モードで構築し、  フロントエンドは Next.js による SPA 構成としています。  

認証やデータ構造の変更が発生した場合でも、UI 側の実装に影響を与えずに対応できるよう、API を介した責務分離を意識しました。  

これにより、バックエンドとフロントエンドをそれぞれ独立して、改善・拡張できる構成としています。

### ゲストユーザーの仕様設計
ゲストログイン機能を実装するにあたり、「1つのアカウントを使い回す方法」と「利用ごとに新規ゲストユーザーを作成する方法」の2案を検討しました。  
複数人が同時に利用できることや、他人のデータが残らないことを重視し、後者の仕様を採用しています。  

その結果、一定期間経過後に不要となるデータが発生することを想定し、データのライフサイクルを意識した設計を行っています。  
不要となったゲストユーザーのデータは、非同期処理によって定期的に削除する構成としています。



## 苦労した点・学んだこと
### ログインが不安定になる問題の原因調査と改善
ログインできる時とできない時が交互に発生する現象が起き、登録ユーザー・ゲストユーザーの両方で同様の問題が確認されました。  

まずはコードのタイポや実装ミスを疑い、フロントエンド・バックエンド双方のコードを確認しましたが、明確なエラーは見つかりませんでした。  
また、技術ブログ等の情報も調査しましたが、同様の事例は見つけられませんでした。  

そこで、ブラウザの開発者ツールを用いて通信状況を確認したところ、ログアウト後も以前ログインしていたユーザーの認証情報がフロントエンド側に残っていることが判明しました。  
ログアウト処理時に uid や token を明示的にリセットするよう修正した結果、ログイン状態は安定し、問題を解消することができました。  

この経験から、認証処理だけでなく、フロントエンドにおける状態管理や初期化処理まで含め、一貫して設計・確認する重要性を学びました。


### ゲストユーザーの自動削除機能の実装
ゲストログインでは利用ごとに新規ユーザーを作成する仕様のため、不要となるゲストユーザーを自動的に削除する仕組みが必要でした。  

当初は rake タスクと cron を組み合わせて定期削除を実装しましたが、Docker 環境では cron が Rails アプリケーションの外側で動作するため、自動実行の管理や再現性の確保が難しいという課題がありました。  
手動実行は可能でしたが、本番環境での安定運用には不安が残る構成でした。  

そこで、処理を Rails アプリケーション内で完結させる方針に切り替え、Sidekiq と Redis を用いた非同期処理基盤を採用しました。  
これにより、定期実行・エラーハンドリング・再実行をアプリケーション側で一元管理できるようになり、Docker 環境でも再現性の高い構成を実現できました。  

実装にあたっては、技術ブログ等を活用して情報収集を行い、本番運用を見据えた場合には Sidekiq + Redis の構成が適していると判断しました。  

結果として、開発環境・本番環境ともに安定して動作する形でデプロイまで完了させることができました。


### 読了日登録時のカレンダーUIの調整
当初は MUI のコンポーネントを用いて読了日入力を実装しましたが、年月の表示形式が「1月 / 2025年」のようになり、「2025年 / 1月」という表示要件を満たすことができませんでした。  
CSS を用いて表示を調整する方法も検討しましたが、スタイルの上書きが複雑になり、UI 要件を安定して満たすことが難しいと判断しました。  

そこで、UI の見た目と柔軟性を重視し、shadcn/ui と react-day-picker を組み合わせた構成に切り替えました。  
実装にあたっては、扱うデータ型の違いにも注意が必要でした。  
react-day-picker と Rails では Date 型を扱う一方で、react-hook-form や API 通信では文字列（String）としてデータを扱う必要がありました。  
そのため、カレンダー（Date）→ フォーム（String）→ API（String）→ Rails（Date）という変換の流れを整理し、console.log やブラウザの開発者ツールを用いて、値を確認しながら実装を進めました。  

この対応を通じて、UI の見た目だけでなく、フロントエンドとバックエンド間でのデータの役割や形式を意識して設計することの重要性を学びました。



## ユーザーフィードバックをもとに改善した点
- **ジャンル機能の追加**  
実際の利用者から、「読書記録をジャンルで絞り込める機能が欲しい」という要望を受け、後からジャンル機能を追加実装しました。  
記事登録時にジャンルを指定できるようにし、読了済一覧ではジャンルによる絞り込み検索に対応しました。  
これにより、目的や分野ごとに過去の読書記録を振り返りやすくなりました。


- **記事登録・編集時に入力した改行が、記事詳細画面で反映されない**  
実際の利用者からの指摘を受け、表示内容を確認したところ、入力時の改行が画面表示に正しく反映されていないことが分かりました。  
表示方法を見直すことで、入力した内容がそのまま画面に反映されるように改善し、記録した内容を違和感なく振り返れるようにしました。  


## 今後の改善予定
- 記事一覧について、読了日の昇順・降順を切り替えられる並び替え機能の追加を検討しています。
- ゲストユーザーとして利用後、本登録へスムーズに移行できるよう導線の改善を検討しています。
